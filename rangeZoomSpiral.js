
var numRotations = 12;
var resolution = .01;
var pathWeight = 1;
var containWithinViewport = true;
var v = 0;
var d = 1;

var getP = function(z, d, v) {
  return Math.log(1 - z) / Math.abs(d - v);
};
var getZ = function(d, v, l) {
  return (5/6) * (1 - (Math.abs(d - v)/l));
};
var getO = function(d, v) {
  return Math.abs(d - v) / (2 * Math.log(5));
};
var getW = function(d, v) {
  return (d + v) / 2;
};
var getC = function(o, w, l, bigP) {
  if (bigP >= 0) {
    return w - (o * Math.log(bigP));
  }
  if (bigP < 0) {
    return (3 * l) * ((w - (l *.5)) / (Math.abs(w - (l *.5))));
  }
};
var getBigP = function(p, l, w) {
  return ((2 * Math.exp(p * (l - w))) - Math.exp(l * p) - 1) / (2 * Math.exp(w * p) - Math.exp(l * p) - 1);
};
var megaSpiral = function(theta, d, v, l) {
  var z = getZ(d, v, l);
  var p = getP(z, d, v);
  var w = getW(d, v);
  var bigP = getBigP(p, l, w);
  var o = getO(d, v);
  var c = getC(o, w, l, bigP);
  return (Math.exp(((theta / (2*Math.PI)) - c) / o) + Math.exp(p * (l - (theta / (2*Math.PI)))))/(Math.exp(((theta / (2*Math.PI)) - c) / o) + 1) * l*(Math.exp((theta*p)/(2*Math.PI))-1)/(Math.exp(p*l)-1);
};

var newDataGenerator = function(d, v, l) {

  var spiralDataGenerator = function(theta) {
    return [theta, megaSpiral(theta, d, v, l)];
  };

  return spiralDataGenerator;

};
// Dummy data for data plotting
var datapoints = d3.range(0, numRotations*2 * Math.PI, .500);

var orig = [1/48 * 2 * Math.PI, 3/48 * 2 * Math.PI, 13/48 * 2 * Math.PI, 22/48 * 2 * Math.PI, 35/48 * 2 * Math.PI, 40/48 * 2 * Math.PI];

// Returns absolute value for v and d.
// Use for wherever 't' occurs in paul's demo
// NOT TO BE CONFUSED WITH 't' for 'theta' here.


// Init width, height of graph container and radius of graph.
var width = 960,
    height = 600,
    radius = Math.min(width, height) / 2 - 30;


// Generates function constraining domain and range of graph
// From what I can tell manipulating the domain values, it seems to just
// hange the scaling of the graph within the viewport.

var r = d3.scale.linear()
    .domain([0, numRotations])
    .range([0, radius]);

// Generates function which will apply a transformation to the data points
// generated by our spiral function and return cartesian coordinates
// used by the <path> element.  The function used in the angle setter is
// changing the data values to orient the graph correctly.
var line = d3.svg.line.radial()
    .radius(function(data) {

      return r(data[1]);

    })
    .angle(function(data) {

      return Math.PI / 2 - data[0];

    });

// Create <svg> element, append it to body, set width and height based on variables
// defined above.  Also create the <g> element which will contain the <path> element.
// Apply transformations to center the graph within the parent container.
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

// Create <path> element with class line and append it to svg's last child <g>
svg.append("path")
    .attr("class", "line")



// Update data points on curve
function updatePoints(range1, range2) {
  // Getting closer...
  var plotData = orig.map(newDataGenerator(range1, range2, numRotations));

  var polarToCarX = function(d) {
    return r(d[1]) * Math.cos(-d[0]);
  };

  var polarToCarY = function(d) {
    return r(d[1]) * Math.sin(-d[0]);
  };

  var circle = svg.selectAll("circle")
      .data(plotData);

  circle.exit().remove();

  circle.enter().append("circle")
      .attr("r", 1.5);

  circle
      .attr("cx", function (d) { return polarToCarX(d); })
      .attr("cy", function (d) { return polarToCarY(d); });
};


// Select the <input> range element and attaches a listener to when the input
// value changes.  On input change, call "update" function with the new value.
d3.selectAll(".rangeSlider").on("input", function() {
  var origD = d;
  var origV = v;

  var id = this.id;

  var d = d3.select("#d")[0][0].value;
  var v = d3.select("#v")[0][0].value;

  // There's surely a better way to do this but saving that for a refactor
  switch (id) {
    case 'd':
      d3.select("#d-value").text(d);
      d3.select("#d").property("value", d);
      break;
    case 'v':
      d3.select("#v-value").text(v);
      d3.select("#v").property("value", v);
      break;
  }


  update(Number(d), Number(v));

});

// Initial starting value of input range sliders.
d3.select("#d-value").text(d);
d3.select("#d").property("value", d);
d3.select("#v-value").text(v);
d3.select("#v").property("value", v);

// Updates the spiral data per the value of the input range slider.
function update(newD, newV) {

  // Generates new data points based on the input value
  //var newData = d3.range(0, 12 * Math.PI, .01).map(inputDataGenerator(n, numRevolutions));
  d = newD;
  v = newV;


  var newData = d3.range(0, numRotations*2*Math.PI, resolution).map(newDataGenerator(newD, newV, numRotations));


  // Apply those new data points.  D3 will use the radial line function
  // that we have previously defined above to map those values to Cartesian coordinates
  // so we need to update the value of the d attribute on the <path> element
  svg.selectAll(".line")
    .datum(newData)
    .attr("d", line)


  updatePoints(newD, newV);

};

update(d,v);


// Select the <input> rotation element and attaches a listener to when the input
// value changes.  On input change, call "updateRotations" function with the new value.
d3.select("#rotationSlider").on("input", function() {
  updateRotations(+Number(this.value));
});

function updateRotations(n) {

  // adjust the text on the range slider
  d3.select("#r-value").text(n);
  d3.select("#rotationSlider").property("value", n);

  numRotations = n;


  if (containWithinViewport == true) {
    r = d3.scale.linear()
      .domain([0, numRotations])
      .range([0, radius]);

  }

  // Generates new data points based on the input value
  //var newData = d3.range(0, 12 * Math.PI, .01).map(inputDataGenerator(n, numRevolutions));

  var newData = d3.range(0, numRotations * 2*Math.PI, resolution).map(newDataGenerator(d, v, numRotations));


  // Apply those new data points.  D3 will use the radial line function
  // that we have previously defined above to map those values to Cartesian coordinates
  // so we need to update the value of the d attribute on the <path> element
  svg.selectAll(".line")
    .datum(newData)
    .attr("d", line)

  d3.selectAll('.rangeSlider')
    .attr("max", n)

  updatePoints(d, v);

};

updateRotations(numRotations);

// Select the <input> rotation element and attaches a listener to when the input
// value changes.  On input change, call "updateResolution" function with the new value.
d3.select("#resolutionSlider").on("input", function() {
  updateResolution(+Number(this.value));
});

function updateResolution(n) {

  // adjust the text on the range slider
  d3.select("#res-value").text(n);
  d3.select("#resolutionSlider").property("value", n);

  resolution = n;

  // Generates new data points based on the input value
  //var newData = d3.range(0, 12 * Math.PI, .01).map(inputDataGenerator(n, numRevolutions));

  var newData = d3.range(0, numRotations * 2*Math.PI, resolution).map(newDataGenerator(d, v, numRotations));


  // Apply those new data points.  D3 will use the radial line function
  // that we have previously defined above to map those values to Cartesian coordinates
  // so we need to update the value of the d attribute on the <path> element
  svg.selectAll(".line")
    .datum(newData)
    .attr("d", line)

};

updateResolution(resolution);

// Select the <input> rotation element and attaches a listener to when the input
// value changes.  On input change, call "updatePathWeight" function with the new value.
d3.select("#path-weight").on("input", function() {
  updatePathWeight(+Number(this.value));
});

function updatePathWeight(n) {

  // adjust the text on the range slider
  d3.select("#path-weight-value").text(n);
  d3.select("#path-weight").property("value", n);

  pathWeight = n;


  // Apply those new data points.  D3 will use the radial line function
  // that we have previously defined above to map those values to Cartesian coordinates
  // so we need to update the value of the d attribute on the <path> element
  svg.selectAll(".line")
    .style('stroke-width', pathWeight + 'px');

};

updatePathWeight(pathWeight);

// Color picker
function updateColor(hsb,hex,rgb,el,bySetColor) {
  var hexStr = '#' + hex;
  svg.selectAll(".line")
    .style('stroke', hexStr);

};


$('#color-picker').colpick({
  flat:true,
  layout:'hex',
  submit:0,
  onChange: updateColor,
  color: '#ff0000'
});

