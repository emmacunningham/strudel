/**
 * @fileoverview Controller class for Spiral Timeline generator.
 */


'use strict';
var strudel = strudel || {};


/**
 * Constructor for SpiralTimelineController.
 * @params {Object} params - parameters for customizing an instance
 * of the timeline.
 * @constructor
 */
strudel.SpiralTimelineController = function(params) {

  /**
   * Whether the graph should be contained within the viewport.
   * @type {Boolean}
   */
  this.containWithinViewport = true;

  /**
   * Number of rotations around the origin.
   * @type {Number}
   */
  this.numRotations = 10;

  /**
   * Resolution of the datapoints drawn on curve.
   * @type {Number}
   */
  this.resolution = .01;

  /**
   * Weight of the stroke used to draw the curve.
   * @type {Number}
   */
  this.pathWeight = 1;

  /**
   * Start of range to zoom over.
   * @type {Number}
   */
  this.zoomRangeStart = 2;

  /**
   * End of range to zoom over.
   * @type {Number}
   */
  this.zoomRangeEnd = 4;

  /**
   * Math helpers.
   * @type {strudel.MathUtils}
   */
  this.utils = new strudel.MathUtils();

  /**
   * Graph container width.
   * @type {Number}
   */
  this.width = 800;

  /**
   * Graph container height.
   * @type {Number}
   */
  this.height = 800;

  /**
   * Graph container radius.
   * @type {Number}
   */
  this.radius = Math.min(this.width, this.height) / 2 - 30;

  /**
   * Function constraining domain and range of graph to fit within
   * graph container dimensions.
   * @type {function}
   */
  this.graphScale = d3.scale.linear()
      .domain([0, this.numRotations])
      .range([0, this.radius]);

  /**
   * For now, dummy data.  When we work with real data we'll want to
   * provide a method that allows you to import JSON or somethin.
   * @type {Array.<Number>}
   */
  this.datapoints = [];
  // Uncomment below to show circles.
  // this.datapoints = d3.range(0, 12 * Math.PI, .500);

  // Store 'this' object in variable name that won't get overwritten within
  // the scope of another function.
  var self = this;

  /**
   * Generates a function which will apply a transformation to the data points
   * generated by our spiral function and return cartesian coordinates
   * used by the <path> element.  The function used in the angle setter is
   * changing the data values to orient the graph correctly.
   * @type {function}
   */
  this.line = d3.svg.line.radial()
      .radius(function(data) {
        return self.graphScale(data[1]);
      })
      .angle(function(data) {
        return Math.PI / 2 - data[0];
      });

  /**
   * Create <svg> element, append it to body, set width and height based on variables
   * defined above.  Also create the <g> element which will contain the <path> element.
   * Apply transformations to center the graph within the parent container.
   * @type {Element}
   */
  this.svg = d3.select("body").append("svg")
      .attr("width", this.width)
      .attr("height", this.height)
      .append("g")
      .attr("transform", "translate(" + this.width / 2 + "," + this.height / 2 + ")");

  // Create <path> element with class line and append it to svg's last child <g>
  this.svg.append("path")
      .attr("class", "line");

  // Create <path> element with class line and append it to svg's last child <g>
  this.tooltip = $('body').append($('<div class="tooltip"></div>'));

  // We may wish to throw all of this into an init method.
  this.initSliders();
  this.addSliderListeners();
  this.initColorPicker();

  setInterval(function() { self.setPointColors(); }, 1500);
};


/**
 * Update path of curve.  Called whenever any data integral to
 * the rendering of the curve are updated.
 */
strudel.SpiralTimelineController.prototype.updatePath = function() {

  var newData = d3.range(0, this.numRotations * 2 * Math.PI, this.resolution)
          .map(this.newDataGenerator(this.zoomRangeEnd, this.zoomRangeStart, this.numRotations));

  // Apply those new data points.  D3 will use the radial line function
  // that we have previously defined above to map those values to Cartesian coordinates
  // so we need to update the value of the d attribute on the <path> element
  this.svg.selectAll(".line")
    .datum(newData)
    //.attr("d", this.line)

  this.updatePoints(this.zoomRangeStart, this.zoomRangeEnd);

};


/**
 * Update zoom points.
 * @param {Number} zoomRangeStart - zoom range start point.
 * @param {Number} zoomRangeEnd - zoom range end point.
 */
strudel.SpiralTimelineController.prototype.updateZoomRange = function(zoomRangeStart, zoomRangeEnd) {

  this.zoomRangeStart = zoomRangeStart;
  this.zoomRangeEnd = zoomRangeEnd;

  this.updatePath();

};

/**
 * Update number of rotations.
 * @param {Number} n - number of rotations.
 */
strudel.SpiralTimelineController.prototype.updateRotations = function(n) {

  // Adjust the text on the range slider.
  d3.select("#r-value").text(n);
  d3.select("#rotationSlider").property("value", n);

  this.numRotations = n;

  // Update scale of graph to fit within viewport.
  if (this.containWithinViewport == true) {
    this.graphScale = d3.scale.linear()
        .domain([0, this.numRotations])
        .range([0, this.radius]);
  }
  // Sets the max value on range slider based on updated rotations value.
  this.updateZoomSlider();

  this.updatePath();
};


/**
 * Update range zoom slider.
 */
strudel.SpiralTimelineController.prototype.updateZoomSlider = function() {
  var self = this;
  this.zoomRangeSlider.updateValues(self.numRotations, self.zoomRangeStart, self.zoomRangeEnd);

};

/**
 * Update resolution of graph - basically the sampling rate of data points
 * to generate the curve.
 * @param {Number} n - resolution value.
 */
strudel.SpiralTimelineController.prototype.updateResolution = function(n) {

  // adjust the text on the range slider
  d3.select("#res-value").text(n);
  d3.select("#resolutionSlider").property("value", n);

  this.resolution = n;

  this.updatePath();

};

/**
 * Updates the path weight of the curve.
 * @param {Number} n - path weight value.
 */
strudel.SpiralTimelineController.prototype.updatePathWeight = function(n) {

  // adjust the text on the range slider
  d3.select("#path-weight-value").text(n);
  d3.select("#path-weight").property("value", n);

  this.pathWeight = n;

  // Apply new path weight here.
  this.svg.selectAll(".line")
      .style('stroke-width', this.pathWeight + 'px');

};

/**
 * Updates the color of the curve, based on values returned from color picker.
 */
strudel.SpiralTimelineController.prototype.updateColor = function(hsb,hex,rgb,el,bySetColor) {
  var hexStr = '#' + hex;
  d3.selectAll(".line")
      .style('stroke', hexStr);
};

/**
 * Initialize color picker.
 */
strudel.SpiralTimelineController.prototype.initColorPicker = function() {
  var self = this;
  $('#color-picker').colpick({
      flat:true,
      layout:'hex',
      submit:0,
      onChange: self.updateColor,
      color: '#b3b3b3'
  });
};


/**
 * Initialize starting value of input sliders and draw initial graph.
 */
strudel.SpiralTimelineController.prototype.initSliders = function() {

  this.zoomRangeSlider = new strudel.ui.ZoomRangeSlider(this.numRotations, this.zoomRangeStart, this.zoomRangeEnd);

  $('#resolutionSlider').attr('step', Math.PI / 16);

  this.updateRotations(this.numRotations);
  this.updateResolution(this.resolution);
  this.updatePathWeight(this.pathWeight);

  this.updatePath();

};

/**
 * Add listeners for each input slider.
 */
strudel.SpiralTimelineController.prototype.addSliderListeners = function() {
  var self = this;

  /* Old slider stuff -- leaving for reference but we're changing the UI
  // Select the <input> range element and attaches a listener to when the input
  // value changes.  On input change, call "update" function with the new value.
  d3.selectAll(".rangeSlider").on("input", function() {
    var id = this.id;

    var zoomRangeStart = d3.select("#d")[0][0].value;
    var zoomRangeEnd = d3.select("#v")[0][0].value;

    // There's surely a better way to do this but saving that for a refactor
    switch (id) {
      case 'd':
        d3.select("#d-value").text(zoomRangeStart);
        d3.select("#d").property("value", zoomRangeStart);
        break;
      case 'v':
        d3.select("#v-value").text(zoomRangeEnd);
        d3.select("#v").property("value", zoomRangeEnd);
        break;
    }


    self.updateZoomRange(Number(zoomRangeStart), Number(zoomRangeEnd));

  });
  */
  // New listeners for range zoom value changes.

  this.zoomRangeSlider.element.on({
    slide: function(){
      var zoomRangeStart = $("#range").val()[0];
      var zoomRangeEnd = $("#range").val()[1];
      //console.log($("#range").val());
      self.updateZoomRange(Number(zoomRangeStart), Number(zoomRangeEnd));
    },
    set: function(){
      var zoomRangeStart = $("#range").val()[0];
      var zoomRangeEnd = $("#range").val()[1];
      //console.log($("#range").val());
      self.updateZoomRange(Number(zoomRangeStart), Number(zoomRangeEnd));
    },
    change: function(){
      var zoomRangeStart = $("#range").val()[0];
      var zoomRangeEnd = $("#range").val()[1];
      //console.log($("#range").val());
      self.updateZoomRange(Number(zoomRangeStart), Number(zoomRangeEnd));
    }
  });


  // Select the <input> rotation element and attaches a listener to when the input
  // value changes.  On input change, call "updateRotations" function with the new value.
  d3.select("#rotationSlider").on("input", function() {
    self.updateRotations(+Number(this.value));
  });

  // Select the <input> rotation element and attaches a listener to when the input
  // value changes.  On input change, call "updateResolution" function with the new value.
  d3.select("#resolutionSlider").on("input", function() {
    self.updateResolution(+Number(this.value));
  });


  // Select the <input> rotation element and attaches a listener to when the input
  // value changes.  On input change, call "updatePathWeight" function with the new value.
  d3.select("#path-weight").on("input", function() {
    self.updatePathWeight(+Number(this.value));
  });

};


/**
 * Returns updated polar coordinates for updated zoom range variables and rotation.
 * @param {Number} zoomRangeStart - zoom range start point.
 * @param {Number} zoomRangeEnd - zoom range end point.
 * @param {Number} l - number of rotations.
 * @return {Array.<Number>} - polar coordinates for theta and radius of a point.
 */
strudel.SpiralTimelineController.prototype.newDataGenerator = function(zoomRangeStart, zoomRangeEnd, l) {
  var self = this;

  var spiralDataGenerator = function(theta) {
    return [theta, self.utils.getRadius(theta, zoomRangeStart, zoomRangeEnd, l)];
  };

  return spiralDataGenerator;

};


/**
 * Update data.
 * @param {Array.<Number>} data - array of datapoints to plot on graph.
 */
strudel.SpiralTimelineController.prototype.updateData = function(data) {

  this.datapoints = data;

  this.updatePoints();

};


/**
 * Attaches metadata to circles.
 */
strudel.SpiralTimelineController.prototype.attachMetadata = function () {
};


/**
 * Fetches relevant points data from complex data array.
 */
strudel.SpiralTimelineController.prototype.getDataPoints = function (array, key) {

  for (var i = 0, l = array.length; i < l; i++) {
    var time = array[i]['time'];

    // retrieve polar coords
    var polarCoords = this.newDataGenerator(this.zoomRangeStart, this.zoomRangeEnd, this.numRotations)(time);

    // append to object
    array[i]['polarCoords'] = polarCoords;

  }

  return array;
};


/**
 * Assign color meaning based on some data.
 */
strudel.SpiralTimelineController.prototype.createColorMap = function (array, key) {

    var uniquePlayers =  _.uniq(_.pluck(array, key));

    // doing some stuff with all unique scoring players so we can automate colors
    function getRandomColor() {
      var letters = '0123456789ABCDEF'.split('');
      var color = '#';
      for (var i = 0; i < 6; i++ ) {
          color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }

    var colorMap = {};
    for (var i = 0, l = uniquePlayers.length; i < l; i++) {
      var key = this.slugify(uniquePlayers[i]);
      var value = getRandomColor();
      colorMap[key] = value;
    }

    return colorMap;

};



/*
 * Prolly could throw this into a utils class if we have more of these.
 */
strudel.SpiralTimelineController.prototype.slugify = function (text) {
  return text.toString().toLowerCase()
    .replace(/\s+/g, '-')           // Replace spaces with -
    .replace(/[^\w\-]+/g, '')       // Remove all non-word chars
    .replace(/\-\-+/g, '-')         // Replace multiple - with single -
    .replace(/^-+/, '')             // Trim - from start of text
    .replace(/-+$/, '');            // Trim - from end of text
};


strudel.SpiralTimelineController.prototype.setPointColors = function () {
  var circle = this.svg.selectAll("circle")
  var self = this;
  var colorMap = this.createColorMap(this.datapoints, 'player');

  circle
    .transition().duration(500)
    .attr('fill', function(d) {
      var playerSlug = self.slugify(d['player']);
      var color = colorMap[playerSlug];
      return color;
    })

};


/**
 * Update data points on curve.
 */
strudel.SpiralTimelineController.prototype.updatePoints = function () {
  var self = this;
  var points = this.getDataPoints(this.datapoints, 'time');
  var plotData = points;

  var colorMap = this.createColorMap(this.datapoints, 'player');

  var polarToCarX = function(d) {
    return self.graphScale(d['polarCoords'][1]) * Math.cos(-d['polarCoords'][0]);
  };

  var polarToCarY = function(d) {
    return self.graphScale(d['polarCoords'][1]) * Math.sin(-d['polarCoords'][0]);
  };

  var circle = this.svg.selectAll("circle")
      .data(plotData);

  var sizes = [];
  circle.exit().remove();

  circle.enter().append("circle")
    .attr('r', function(d) {
        var size = d['points'] * 3;
        return size;
    })
    .attr('player', function(d) {
      return d['player'];
    })
    .attr('points', function(d) {
      return d['points'];
    })
    .attr('opacity', function(d) {
      return 1;
    })

  this.setPointColors();

  circle
      .attr("cx", function (d) { return polarToCarX(d); })
      .attr("cy", function (d) { return polarToCarY(d); });

  circle.on('click', function() {
    //alert($(this).attr('player') + ' scores ' + $(this).attr('points'));
    self.updateTooltip(this, {'player': $(this).attr('player'), 'points': $(this).attr('points')});
  });

};

/**
 * Update tooltip based on metadata.
 */
strudel.SpiralTimelineController.prototype.updateTooltip = function(el, data) {
  $('.tooltip').empty();
  var tooltipDetails = $('<div class="tooltip-player">Player: ' + data['player'] + '</div>' +
                  '<div class="tooltip-points">Points: ' + data['points'] + '</div>');
  console.log(tooltipDetails)
  $('.tooltip').append(tooltipDetails);
};